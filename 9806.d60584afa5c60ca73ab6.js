"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9806],{9806:function(e,a,t){t.r(a),t(7378);var n=t(2682);function l(){return l=Object.assign?Object.assign.bind():function(e){for(var a=1;a<arguments.length;a++){var t=arguments[a];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e},l.apply(this,arguments)}function r(e){let{components:a,...t}=e;return(0,n.kt)("wrapper",l({components:a},t),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"Compiler")," 使用 ",(0,n.kt)("inlineCode",{parentName:"p"},"ContextModuleFactory")," 模块从 webpack 独特的 ",(0,n.kt)("a",{href:"/api/module-methods/#requirecontext",parentName:"p"},"require.context")," API 生成依赖关系。它会解析请求的目录，为每个文件生成请求，并依据传递来的 regExp 进行过滤。最后匹配成功的依赖关系将被传入 ",(0,n.kt)("a",{href:"/api/normalmodulefactory-hooks",parentName:"p"},"NormalModuleFactory"),"。"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"ContextModuleFactory")," 类扩展了 ",(0,n.kt)("inlineCode",{parentName:"p"},"Tapable")," 并提供了以下的生命周期钩子。\n你可以像使用编译器钩子一样使用它们："),(0,n.kt)("pre",null,(0,n.kt)("code",{className:"hljs language-js",parentName:"pre"},"ContextModuleFactory",(0,n.kt)("span",{className:"token punctuation",parentName:"code"},"."),"hooks",(0,n.kt)("span",{className:"token punctuation",parentName:"code"},"."),"someHook",(0,n.kt)("span",{className:"token punctuation",parentName:"code"},"."),(0,n.kt)("span",{className:"token function",parentName:"code"},"tap"),(0,n.kt)("span",{className:"token punctuation",parentName:"code"},"("),(0,n.kt)("span",{className:"token comment",parentName:"code"},"/* ... */"),(0,n.kt)("span",{className:"token punctuation",parentName:"code"},")"),(0,n.kt)("span",{className:"token punctuation",parentName:"code"},";"))),(0,n.kt)("p",null,"与 ",(0,n.kt)("inlineCode",{parentName:"p"},"compiler")," 一样，",(0,n.kt)("inlineCode",{parentName:"p"},"tapAsync")," 和 ",(0,n.kt)("inlineCode",{parentName:"p"},"tapPromise")," 是否可用\n取决于钩子的类型。"),(0,n.kt)("h3",null,(0,n.kt)("span",{id:"beforeresolve",parentName:"h3"}),"beforeResolve",(0,n.kt)("a",{href:"#beforeresolve","aria-hidden":"true",tabIndex:"-1",parentName:"h3"},(0,n.kt)("span",{className:"header-link",parentName:"a"}))),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"AsyncSeriesWaterfallHook")),(0,n.kt)("p",null,"在解析请求的目录之前调用。请求可以通过返回 ",(0,n.kt)("inlineCode",{parentName:"p"},"false")," 来忽略。"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"回调参数：",(0,n.kt)("inlineCode",{parentName:"li"},"data"))),(0,n.kt)("h3",null,(0,n.kt)("span",{id:"afterresolve",parentName:"h3"}),"afterResolve",(0,n.kt)("a",{href:"#afterresolve","aria-hidden":"true",tabIndex:"-1",parentName:"h3"},(0,n.kt)("span",{className:"header-link",parentName:"a"}))),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"AsyncSeriesWaterfallHook")),(0,n.kt)("p",null,"在请求的目录解析后调用。"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"回调参数：",(0,n.kt)("inlineCode",{parentName:"li"},"data"))),(0,n.kt)("h3",null,(0,n.kt)("span",{id:"contextmodulefiles",parentName:"h3"}),"contextModuleFiles",(0,n.kt)("a",{href:"#contextmodulefiles","aria-hidden":"true",tabIndex:"-1",parentName:"h3"},(0,n.kt)("span",{className:"header-link",parentName:"a"}))),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"SyncWaterfallHook")),(0,n.kt)("p",null,"读取目录内容后调用。在递归模式下，也会读取每个子目录。回调参数是一个包含每个目录中所有文件和文件夹名称的数组。"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"回调参数：",(0,n.kt)("inlineCode",{parentName:"li"},"fileNames"))),(0,n.kt)("h3",null,(0,n.kt)("span",{id:"alternativerequests",parentName:"h3"}),"alternativeRequests",(0,n.kt)("a",{href:"#alternativerequests","aria-hidden":"true",tabIndex:"-1",parentName:"h3"},(0,n.kt)("span",{className:"header-link",parentName:"a"}))),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"AsyncSeriesWaterfallHook")),(0,n.kt)("p",null,"在创建请求之后但依据 regExp 进行过滤之前，为每个文件调用。"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"回调参数：",(0,n.kt)("inlineCode",{parentName:"li"},"request")," ",(0,n.kt)("inlineCode",{parentName:"li"},"options"))))}r.isMDXComponent=!0,a.default=r}}]);