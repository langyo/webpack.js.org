"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7154],{7154:function(e,t,a){a.r(t),a(7378);var p=a(2682);function n(){return n=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var p in a)Object.prototype.hasOwnProperty.call(a,p)&&(e[p]=a[p])}return e},n.apply(this,arguments)}function r(e){let{components:t,...a}=e;return(0,p.kt)("wrapper",n({components:t},a),(0,p.kt)("p",null,"每当一个文件依赖另一个文件时，webpack 都会将文件视为直接存在 ",(0,p.kt)("em",{parentName:"p"},"依赖关系"),"。这使得 webpack 可以获取非代码资源，如 images 或 web 字体等。并会把它们作为 ",(0,p.kt)("em",{parentName:"p"},"依赖")," 提供给应用程序。"),(0,p.kt)("p",null,"当 webpack 处理应用程序时，它会根据命令行参数中或配置文件中定义的模块列表开始处理。\n从 ",(0,p.kt)("a",{href:"/concepts/entry-points/",parentName:"p"},(0,p.kt)("em",{parentName:"a"},"入口"))," 开始，webpack 会递归的构建一个 ",(0,p.kt)("em",{parentName:"p"},"依赖关系图"),"，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为少量的 ",(0,p.kt)("em",{parentName:"p"},"bundle")," —— 通常只有一个 —— 可由浏览器加载。"),(0,p.kt)("aside",{className:"tip"},(0,p.kt)("h6",{className:"tip__prefix",parentName:"aside"},"提示"),(0,p.kt)("p",{parentName:"aside"},"对于 ",(0,p.kt)("em",{parentName:"p"},"HTTP/1.1")," 的应用程序来说，由 webpack 构建的 bundle 非常强大。当浏览器发起请求时，它能最大程度的减少应用的等待时间。而对于 ",(0,p.kt)("em",{parentName:"p"},"HTTP/2")," 来说，你还可以使用",(0,p.kt)("a",{href:"/guides/code-splitting/",parentName:"p"},"代码分离"),"进行进一步优化。")))}r.isMDXComponent=!0,t.default=r}}]);